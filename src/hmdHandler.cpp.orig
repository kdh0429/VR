    #include "hmdHandler.h"

void ThreadSleep(unsigned long nMilliseconds)
{
#if defined(_WIN32)
    ::Sleep(nMilliseconds);
#elif defined(POSIX)
    usleep(nMilliseconds * 1000);
#endif
}


/* HMD Constructor IMPLEMENTATION*/
HMD::HMD(int arc, char* arv[])
    : m_pCompanionWindow(NULL)
    , m_pContext(NULL)
    , m_nCompanionWindowWidth(640)
    , m_nCompanionWindowHeight(320)
    , m_unSceneProgramID(0)
    , m_unCompanionWindowProgramID(0)
    , m_unControllerTransformProgramID(0)
    , m_unRenderModelProgramID(0)
    , m_bDebugOpenGL(false)
    , m_bVerbose(false)
    , m_bPerf(false)
    , m_bVblank(false)
    , m_bGlFinishHack(true)
    , m_glControllerVertBuffer(0)
    , m_unControllerVAO(0)

    , m_nSceneMatrixLocation(-1)
    , m_nControllerMatrixLocation(-1)
    , m_nRenderModelMatrixLocation(-1)
    , m_iTrackedControllerCount(0)
    , m_iTrackedControllerCount_Last(-1)
    , m_iValidPoseCount(0)
    , m_iValidPoseCount_Last(-1)
    , m_iSceneVolumeInit(1)
    , m_strPoseClasses("")
    , m_bShowCubes(true)

{
    
    this->argc_arg = arc;
    this->argv_arg = arv;
    checkControllers = false;
    pubPose = false;
    memset(m_rDevClassChar, 0, sizeof(m_rDevClassChar));



}

/* HMD Destructor IMPLEMENTATION*/
HMD::~HMD() {
    // memory release is done in Shutdown 
}

std::string GetTrackedDeviceString(vr::TrackedDeviceIndex_t unDevice, vr::TrackedDeviceProperty prop, vr::TrackedPropertyError* peError = NULL) {
    uint32_t unRequiredBufferLen = vr::VRSystem()->GetStringTrackedDeviceProperty(unDevice, prop, NULL, 0, peError);
    if (unRequiredBufferLen == 0) return "";
    
    char* pchBuffer = new char[unRequiredBufferLen];
    unRequiredBufferLen = vr::VRSystem()->GetStringTrackedDeviceProperty(unDevice, prop, pchBuffer, unRequiredBufferLen, peError);
    std::string sResult = pchBuffer;
    delete[] pchBuffer;
    return sResult;

}

void streamCallback(const std_msgs::UInt8MultiArray::ConstPtr& streamPacket, ricohRos* streamPtr, HMD* hmdPtr) {
    clock_t start, end;
    //::cout << streamPacket->layout.dim[4].label << std::endl;



    //cout << streamPtr->ricohPacket.size << endl;
    //memcpy(streamPtr->ricohPacket.data, tmp, streamPtr->ricohPacket.size);

    streamPtr->ricohPacket.data = (uint8_t*)&(streamPacket->data[0]);
    int gotFrame = 0;

    if (!(hmdPtr->streamParamInit)) {
        std::cout << "First streaminng input is recognized.. streaming parameters starts to be initialized" << std::endl;
        hmdPtr->width = streamPacket->layout.dim[1].size;
        hmdPtr->height = streamPacket->layout.dim[0].size;
        hmdPtr->leftCvEquirect = cv::Mat(hmdPtr->height, hmdPtr->width, CV_8UC3);
        hmdPtr->leftDat.data[0] = (uint8_t*)(hmdPtr->leftCvEquirect).data;
        hmdPtr->rightCvEquirect = cv::Mat(hmdPtr->height, hmdPtr->width, CV_8UC3);
        hmdPtr->rightDat.data[0] = (uint8_t*)(hmdPtr->rightCvEquirect).data;

        avpicture_fill((AVPicture*)&(hmdPtr->leftDat), (hmdPtr->leftDat).data[0], AV_PIX_FMT_BGR24, hmdPtr->width, hmdPtr->height);
        avpicture_fill((AVPicture*)&(hmdPtr->rightDat), (hmdPtr->rightDat).data[0], AV_PIX_FMT_BGR24, hmdPtr->width, hmdPtr->height);

        hmdPtr->streamParamInit = true;
    }
    start = clock();
    streamPtr->ricohPacket.size = streamPacket->layout.dim[3].size;
    int left_len = avcodec_decode_video2(streamPtr->c, streamPtr->ricohleftFrame, &gotFrame, &(streamPtr->ricohPacket));
    if (left_len < 0 || !gotFrame) {
        std::cout << "Could not Decode left ricoh H264 stream" << std::endl;
        return;
    }
    gotFrame = 0;

    streamPtr->ricohPacket.size = streamPacket->layout.dim[4].size;
    streamPtr->ricohPacket.data = (uint8_t*)(&(streamPacket->data[0]) + streamPacket->layout.dim[3].size);
    int right_len = avcodec_decode_video2(streamPtr->c, streamPtr->ricohrightFrame, &gotFrame, &(streamPtr->ricohPacket));
    if (right_len < 0 || !gotFrame) {
        std::cout << "Could not Decode right ricoh H264 stream" << std::endl;
        return;
    }

    end = clock();
    //cout << (double)(end - start) / CLOCKS_PER_SEC << endl;


    hmdPtr->leftCvEquirect = cv::Mat(hmdPtr->height, hmdPtr->width, CV_8UC3);
    (hmdPtr->leftDat).data[0] = (uint8_t*)(hmdPtr->leftCvEquirect).data;

    hmdPtr->rightCvEquirect = cv::Mat(hmdPtr->height, hmdPtr->width, CV_8UC3);
    (hmdPtr->rightDat).data[0] = (uint8_t*)(hmdPtr->rightCvEquirect).data;

    //avpicture_fill((AVPicture*)&dst, dst.data[0], AV_PIX_FMT_BGR24, hmdPtr->width, hmdPtr->height);



    if (left_len < 0 || !gotFrame) {
        std::cout << "Could not Decode ricoh H264 stream" << std::endl;
        return;
    }

    hmdPtr->left_Pixfmt = (enum AVPixelFormat)streamPtr->ricohleftFrame->format;
    hmdPtr->right_Pixfmt = (enum AVPixelFormat)streamPtr->ricohrightFrame->format;

    if (hmdPtr->left_Pixfmt != hmdPtr->right_Pixfmt) {
        std::cout << "Left, Right Pixel Format are different. Please adjust format" << std::endl;
        return;
    }

    streamPtr->ricohContext = sws_getContext(hmdPtr->width, hmdPtr->height, hmdPtr->left_Pixfmt, hmdPtr->width, hmdPtr->height, AV_PIX_FMT_BGR24,
        SWS_FAST_BILINEAR, NULL, NULL, NULL);

    if (streamPtr->ricohContext == NULL) {
        fprintf(stderr, "Cannot initialize context\n");
        std::cout << "Cannot initialize context" << std::endl;
        return;
    }

    sws_scale(streamPtr->ricohContext, streamPtr->ricohleftFrame->data,
        streamPtr->ricohleftFrame->linesize, 0,
        hmdPtr->height,
        (hmdPtr->leftDat).data, (hmdPtr->leftDat).linesize);

    sws_scale(streamPtr->ricohContext, streamPtr->ricohrightFrame->data,
        streamPtr->ricohrightFrame->linesize, 0,
        hmdPtr->height,
        (hmdPtr->rightDat).data, (hmdPtr->rightDat).linesize);

    bool LeftconversionSuccess = true;
    bool RightconversionSuccess = true;

    start = clock();
    LeftconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->leftCvEquirect, hmdPtr->LeftcubeFront, CubeFaceName::Front, 0);
    LeftconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->leftCvEquirect, hmdPtr->LeftcubeBack, CubeFaceName::Back, 0);
    LeftconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->leftCvEquirect, hmdPtr->LeftcubeLeft, CubeFaceName::Left, 0);
    LeftconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->leftCvEquirect, hmdPtr->LeftcubeRight, CubeFaceName::Right, 0);
    LeftconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->leftCvEquirect, hmdPtr->LeftcubeTop, CubeFaceName::Top, 0);
    LeftconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->leftCvEquirect, hmdPtr->LeftcubeBottom, CubeFaceName::Bottom, 0);

    RightconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->rightCvEquirect, hmdPtr->RightcubeFront, CubeFaceName::Front, 1);
    RightconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->rightCvEquirect, hmdPtr->RightcubeBack, CubeFaceName::Back, 1);
    RightconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->rightCvEquirect, hmdPtr->RightcubeLeft, CubeFaceName::Left, 1);
    RightconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->rightCvEquirect, hmdPtr->RightcubeRight, CubeFaceName::Right, 1);
    RightconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->rightCvEquirect, hmdPtr->RightcubeTop, CubeFaceName::Top, 1);
    RightconversionSuccess &= hmdPtr->createCubeMapFace(hmdPtr->rightCvEquirect, hmdPtr->RightcubeBottom, CubeFaceName::Bottom, 1);

    cv::imshow("LEFT front", hmdPtr->LeftcubeBack);
    cv::imshow("RIGHT front", hmdPtr->RightcubeBack);

    end = clock();
    //cout << (double)(end - start) / CLOCKS_PER_SEC << endl;
    cv::flip(hmdPtr->LeftcubeFront, hmdPtr->LeftcubeFront, 1);
    cv::cvtColor(hmdPtr->LeftcubeFront, hmdPtr->LeftcubeFront, CV_BGR2RGBA);
    
    cv::flip(hmdPtr->LeftcubeBack, hmdPtr->LeftcubeBack, 1);
    cv::cvtColor(hmdPtr->LeftcubeBack, hmdPtr->LeftcubeBack, CV_BGR2RGBA);
    
    cv::flip(hmdPtr->LeftcubeTop, hmdPtr->LeftcubeTop, 1);
    cv::rotate(hmdPtr->LeftcubeTop, hmdPtr->LeftcubeTop, cv::ROTATE_90_COUNTERCLOCKWISE);
    cv::cvtColor(hmdPtr->LeftcubeTop, hmdPtr->LeftcubeTop, CV_BGR2RGBA);
    
    cv::flip(hmdPtr->LeftcubeBottom, hmdPtr->LeftcubeBottom, 0);
    cv::rotate(hmdPtr->LeftcubeBottom, hmdPtr->LeftcubeBottom, cv::ROTATE_90_COUNTERCLOCKWISE);

    cv::cvtColor(hmdPtr->LeftcubeBottom, hmdPtr->LeftcubeBottom, CV_BGR2RGBA);
    
    cv::flip(hmdPtr->LeftcubeLeft, hmdPtr->LeftcubeLeft, 1);
    cv::cvtColor(hmdPtr->LeftcubeLeft, hmdPtr->LeftcubeLeft, CV_BGR2RGBA);
    
    cv::flip(hmdPtr->LeftcubeRight, hmdPtr->LeftcubeRight, 1);
    cv::cvtColor(hmdPtr->LeftcubeRight, hmdPtr->LeftcubeRight, CV_BGR2RGBA);


    for (int i = 0; i < 6; i++) {
        glBindTexture(GL_TEXTURE_2D, hmdPtr->m_Texture[i]);

        switch (i) {
        case 0:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, hmdPtr->LeftcubeFront.cols, hmdPtr->LeftcubeFront.rows,
                0, GL_RGBA, GL_UNSIGNED_BYTE, &hmdPtr->LeftcubeFront.data[0]);
            break;
        case 1:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, hmdPtr->LeftcubeBack.cols, hmdPtr->LeftcubeBack.rows,
                0, GL_RGBA, GL_UNSIGNED_BYTE, &hmdPtr->LeftcubeBack.data[0]);
            break;
        case 2:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, hmdPtr->LeftcubeTop.cols, hmdPtr->LeftcubeTop.rows,
                0, GL_RGBA, GL_UNSIGNED_BYTE, &hmdPtr->LeftcubeTop.data[0]);
            break;
        case 3:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, hmdPtr->LeftcubeBottom.cols, hmdPtr->LeftcubeBottom.rows,
                0, GL_RGBA, GL_UNSIGNED_BYTE, &hmdPtr->LeftcubeBottom.data[0]);
            break;
        case 4:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, hmdPtr->LeftcubeLeft.cols, hmdPtr->LeftcubeLeft.rows,
                0, GL_RGBA, GL_UNSIGNED_BYTE, &hmdPtr->LeftcubeLeft.data[0]);
            break;
        case 5:
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, hmdPtr->LeftcubeRight.cols, hmdPtr->LeftcubeRight.rows,
                0, GL_RGBA, GL_UNSIGNED_BYTE, &hmdPtr->LeftcubeRight.data[0]);

        }
        
        glGenerateMipmap(GL_TEXTURE_2D);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

        GLfloat fLargest;
        glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &fLargest);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, fLargest);

        glBindTexture(GL_TEXTURE_2D, 0);


    }


    //cv::resize(hmdPtr->leftCvEquirect, hmdPtr->leftCvEquirect, cv::Size(640, 480), 0, 0, CV_INTER_NN);
    //cv::resize(hmdPtr->rightCvEquirect, hmdPtr->rightCvEquirect, cv::Size(640, 480), 0, 0, CV_INTER_NN);
    //cv::imshow("left equirect", hmdPtr->leftCvEquirect);
    //cv::imshow("right equirect", hmdPtr->rightCvEquirect);


   
   /* cv::imshow("LEFT back face", hmdPtr->LeftcubeBack);
    cv::imshow("LEFT left face", hmdPtr->LeftcubeLeft);
    cv::imshow("LEFT Right face", hmdPtr->LeftcubeRight);
    cv::imshow("LEFT Top face", hmdPtr->LeftcubeTop);
    cv::imshow("LEFT Bottom face", hmdPtr->LeftcubeBottom);

    cv::imshow("RIGHT back face", hmdPtr->RightcubeBack);
    cv::imshow("RIGHT left face", hmdPtr->RightcubeLeft);
    cv::imshow("RIGHT Right face", hmdPtr->RightcubeRight);
    cv::imshow("RIGHT Top face", hmdPtr->RightcubeTop);
    cv::imshow("RIGHT Bottom face", hmdPtr->RightcubeBottom);*/
    cv::waitKey(1);

}

/* Shader Compiler  */
GLuint HMD::CompileGLShader(const char* pchShaderName, const char* pchVertexShader, const char* pchFragmentShader)
{
    GLuint unProgramID = glCreateProgram();

    GLuint nSceneVertexShader = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(nSceneVertexShader, 1, &pchVertexShader, NULL);
    glCompileShader(nSceneVertexShader);

    GLint vShaderCompiled = GL_FALSE;
    glGetShaderiv(nSceneVertexShader, GL_COMPILE_STATUS, &vShaderCompiled);
    if (vShaderCompiled != GL_TRUE)
    {
        std::cout << "Unable to compile vertex shader!" << std::endl;

        glDeleteProgram(unProgramID);
        glDeleteShader(nSceneVertexShader);
        return 0;
    }
    glAttachShader(unProgramID, nSceneVertexShader);
    glDeleteShader(nSceneVertexShader); // the program hangs onto this once it's attached

    GLuint  nSceneFragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(nSceneFragmentShader, 1, &pchFragmentShader, NULL);
    glCompileShader(nSceneFragmentShader);

    GLint fShaderCompiled = GL_FALSE;
    glGetShaderiv(nSceneFragmentShader, GL_COMPILE_STATUS, &fShaderCompiled);
    if (fShaderCompiled != GL_TRUE)
    {
        std::cout<<"Unable to compile fragment shader" << std::endl;

        glDeleteProgram(unProgramID);
        glDeleteShader(nSceneFragmentShader);
        return 0;
    }

    glAttachShader(unProgramID, nSceneFragmentShader);
    glDeleteShader(nSceneFragmentShader); // the program hangs onto this once it's attached

    glLinkProgram(unProgramID);

    GLint programSuccess = GL_TRUE;
    glGetProgramiv(unProgramID, GL_LINK_STATUS, &programSuccess);
    if (programSuccess != GL_TRUE)
    {
        std::cout<<"Error linking program" << std::endl;
        glDeleteProgram(unProgramID);
        return 0;
    }

    glUseProgram(unProgramID);
    glUseProgram(0);

    return unProgramID;
}

bool HMD::CreateAllShaders()
{
    m_unSceneProgramID = CompileGLShader(
        "Scene",

        // Vertex Shader
        "#version 410\n"
        "uniform mat4 matrix;\n"
        "layout(location = 0) in vec4 position;\n"
        "layout(location = 1) in vec2 v2UVcoordsIn;\n"
        "layout(location = 2) in vec3 v3NormalIn;\n"
        "out vec2 v2UVcoords;\n"
        "void main()\n"
        "{\n"
        "	v2UVcoords = v2UVcoordsIn;\n"
        "	gl_Position = matrix * position;\n"
        "}\n",

        // Fragment Shader
        "#version 410 core\n"
        "uniform sampler2D mytexture;\n"
        "in vec2 v2UVcoords;\n"
        "out vec4 outputColor;\n"
        "void main()\n"
        "{\n"
        "   outputColor = texture(mytexture, v2UVcoords);\n"
        "}\n"
    );
    m_nSceneMatrixLocation = glGetUniformLocation(m_unSceneProgramID, "matrix");
    if (m_nSceneMatrixLocation == -1)
    {
        std::cout << "Unable to find matrix uniform in scene shader" << std::endl;
        return false;
    }

    m_unControllerTransformProgramID = CompileGLShader(
        "Controller",

        // vertex shader
        "#version 410\n"
        "uniform mat4 matrix;\n"
        "layout(location = 0) in vec4 position;\n"
        "layout(location = 1) in vec3 v3ColorIn;\n"
        "out vec4 v4Color;\n"
        "void main()\n"
        "{\n"
        "	v4Color.xyz = v3ColorIn; v4Color.a = 1.0;\n"
        "	gl_Position = matrix * position;\n"
        "}\n",

        // fragment shader
        "#version 410\n"
        "in vec4 v4Color;\n"
        "out vec4 outputColor;\n"
        "void main()\n"
        "{\n"
        "   outputColor = v4Color;\n"
        "}\n"
    );
    m_nControllerMatrixLocation = glGetUniformLocation(m_unControllerTransformProgramID, "matrix");
    if (m_nControllerMatrixLocation == -1)
    {
        std::cout << "Unable to find matrix uniform in controller shader" << std::endl;
        return false;
    }

    m_unRenderModelProgramID = CompileGLShader(
        "render model",

        // vertex shader
        "#version 410\n"
        "uniform mat4 matrix;\n"
        "layout(location = 0) in vec4 position;\n"
        "layout(location = 1) in vec3 v3NormalIn;\n"
        "layout(location = 2) in vec2 v2TexCoordsIn;\n"
        "out vec2 v2TexCoord;\n"
        "void main()\n"
        "{\n"
        "	v2TexCoord = v2TexCoordsIn;\n"
        "	gl_Position = matrix * vec4(position.xyz, 1);\n"
        "}\n",

        //fragment shader
        "#version 410 core\n"
        "uniform sampler2D diffuse;\n"
        "in vec2 v2TexCoord;\n"
        "out vec4 outputColor;\n"
        "void main()\n"
        "{\n"
        "   outputColor = texture( diffuse, v2TexCoord);\n"
        "}\n"

    );
    m_nRenderModelMatrixLocation = glGetUniformLocation(m_unRenderModelProgramID, "matrix");
    if (m_nRenderModelMatrixLocation == -1)
    {
        std::cout<<"Unable to find matrix uniform in render model shader"<<std::endl;

        return false;
    }

    m_unCompanionWindowProgramID = CompileGLShader(
        "CompanionWindow",

        // vertex shader
        "#version 410 core\n"
        "layout(location = 0) in vec4 position;\n"
        "layout(location = 1) in vec2 v2UVIn;\n"
        "noperspective out vec2 v2UV;\n"
        "void main()\n"
        "{\n"
        "	v2UV = v2UVIn;\n"
        "	gl_Position = position;\n"
        "}\n",

        // fragment shader
        "#version 410 core\n"
        "uniform sampler2D mytexture;\n"
        "noperspective in vec2 v2UV;\n"
        "out vec4 outputColor;\n"
        "void main()\n"
        "{\n"
        "		outputColor = texture(mytexture, v2UV);\n"
        "}\n"
    );

    return m_unSceneProgramID != 0
        && m_unControllerTransformProgramID != 0
        && m_unRenderModelProgramID != 0
        && m_unCompanionWindowProgramID != 0;
}

/* Setup OpenGL Texture using image  */
bool HMD::SetupTexturemaps()
{
    std::string sExecutableDirectory = Path_StripFilename(Path_GetExecutablePath());
    std::string strFullPath = Path_MakeAbsolute("C:/Users/Dyros/Desktop/avatar/src/VR/src/panorama.png", sExecutableDirectory);

    std::vector<unsigned char> imageRGBA;
 
    unsigned nImageWidth, nImageHeight;
    unsigned nError = lodepng::decode(imageRGBA, nImageWidth, nImageHeight, strFullPath.c_str());

    if (nError != 0) {
        std::cout << "Setupe Texture map process failed.. program exit" << std::endl;
        return false;
    }
    //std::cout << imageRGBA.size() << std::endl; 
    for (int i = 0; i < 6; i++) {
        glGenTextures(1, &m_Texture[i]);
        glBindTexture(GL_TEXTURE_2D, m_Texture[i]);


        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, nImageWidth, nImageHeight,
            0, GL_RGBA, GL_UNSIGNED_BYTE, &imageRGBA[0]);

        glGenerateMipmap(GL_TEXTURE_2D);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

        GLfloat fLargest;
        glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &fLargest);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, fLargest);

        glBindTexture(GL_TEXTURE_2D, 0);
    }
    return true;
}

void HMD::AddCubeVertex(float fl0, float fl1, float fl2, float fl3, float fl4, std::vector<float>& vertdata)
{
    vertdata.push_back(fl0);
    vertdata.push_back(fl1);
    vertdata.push_back(fl2);
    vertdata.push_back(fl3);
    vertdata.push_back(fl4);
}

/* Make Cube geometry  */
void HMD::AddCubeToScene(Matrix4 mat, std::vector<float>& vertdata, int flag)
{
    // Matrix4 mat( outermat.data() );

    Vector4 A = mat * Vector4(-0.5, 0, -0.5, 1);
    Vector4 B = mat * Vector4(0.5, 0, -0.5, 1);
    Vector4 C = mat * Vector4(0.5, 1, -0.5, 1);
    Vector4 D = mat * Vector4(-0.5, 1, -0.5, 1);
    Vector4 E = mat * Vector4(-0.5, 0, 0.5, 1);
    Vector4 F = mat * Vector4(0.5, 0, 0.5, 1);
    Vector4 G = mat * Vector4(0.5, 1, 0.5, 1);
    Vector4 H = mat * Vector4(-0.5, 1, 0.5, 1);

    if (flag == 0){
        // triangles instead of quads
        AddCubeVertex(E.x, E.y, E.z, 0, 1, vertdata); //Front
        AddCubeVertex(F.x, F.y, F.z, 1, 1, vertdata);
        AddCubeVertex(G.x, G.y, G.z, 1, 0, vertdata);
        AddCubeVertex(G.x, G.y, G.z, 1, 0, vertdata);
        AddCubeVertex(H.x, H.y, H.z, 0, 0, vertdata);
        AddCubeVertex(E.x, E.y, E.z, 0, 1, vertdata);
    }
    else if (flag == 1) {
        AddCubeVertex(B.x, B.y, B.z, 0, 1, vertdata); //Back
        AddCubeVertex(A.x, A.y, A.z, 1, 1, vertdata);
        AddCubeVertex(D.x, D.y, D.z, 1, 0, vertdata);
        AddCubeVertex(D.x, D.y, D.z, 1, 0, vertdata);
        AddCubeVertex(C.x, C.y, C.z, 0, 0, vertdata);
        AddCubeVertex(B.x, B.y, B.z, 0, 1, vertdata);
    }
    else if (flag == 2) {
        AddCubeVertex(H.x, H.y, H.z, 0, 1, vertdata); //Top
        AddCubeVertex(G.x, G.y, G.z, 1, 1, vertdata);
        AddCubeVertex(C.x, C.y, C.z, 1, 0, vertdata);
        AddCubeVertex(C.x, C.y, C.z, 1, 0, vertdata);
        AddCubeVertex(D.x, D.y, D.z, 0, 0, vertdata);
        AddCubeVertex(H.x, H.y, H.z, 0, 1, vertdata);
    }
    else if (flag == 3) {
        AddCubeVertex(A.x, A.y, A.z, 0, 1, vertdata); //Bottom
        AddCubeVertex(B.x, B.y, B.z, 1, 1, vertdata);
        AddCubeVertex(F.x, F.y, F.z, 1, 0, vertdata);
        AddCubeVertex(F.x, F.y, F.z, 1, 0, vertdata);
        AddCubeVertex(E.x, E.y, E.z, 0, 0, vertdata);
        AddCubeVertex(A.x, A.y, A.z, 0, 1, vertdata);
    }
    else if (flag == 5) {
        AddCubeVertex(A.x, A.y, A.z, 0, 1, vertdata); //Left
        AddCubeVertex(E.x, E.y, E.z, 1, 1, vertdata);
        AddCubeVertex(H.x, H.y, H.z, 1, 0, vertdata);
        AddCubeVertex(H.x, H.y, H.z, 1, 0, vertdata);
        AddCubeVertex(D.x, D.y, D.z, 0, 0, vertdata);
        AddCubeVertex(A.x, A.y, A.z, 0, 1, vertdata);
    }
    else {
        AddCubeVertex(F.x, F.y, F.z, 0, 1, vertdata); //Right
        AddCubeVertex(B.x, B.y, B.z, 1, 1, vertdata);
        AddCubeVertex(C.x, C.y, C.z, 1, 0, vertdata);
        AddCubeVertex(C.x, C.y, C.z, 1, 0, vertdata);
        AddCubeVertex(G.x, G.y, G.z, 0, 0, vertdata);
        AddCubeVertex(F.x, F.y, F.z, 0, 1, vertdata);
    }
}

/* create sea of cubes */
void HMD::SetupScene()
{
    if (!VRSystem) {
        std::cout << "Setupe scene process failed.. program exit" << std::endl;
        return;
    }

    std::vector<std::vector<float>> vertdataarrays;
    for (int i = 0; i < 6; i++) {
        std::vector<float> array;
        vertdataarrays.push_back(array);
    }

    Matrix4 matScale;
    matScale.scale(m_fScale, m_fScale, m_fScale);
    Matrix4 matTransform;
    matTransform.translate(
        -((float)m_iSceneVolumeWidth * m_fScaleSpacing) / 2.f,
        -((float)m_iSceneVolumeHeight * m_fScaleSpacing) / 2.f,
        -((float)m_iSceneVolumeDepth * m_fScaleSpacing) / 2.f);

    
    
    for (int i = 0; i < 6; i++) {

        Matrix4 mat = matScale * matTransform;

        for (int z = 0; z < m_iSceneVolumeDepth; z++)
        {
            for (int y = 0; y < m_iSceneVolumeHeight; y++)
            {
                for (int x = 0; x < m_iSceneVolumeWidth; x++)
                {
                    AddCubeToScene(mat, vertdataarrays[i], i);
                    mat = mat * Matrix4().translate(m_fScaleSpacing, 0, 0);
                }
                mat = mat * Matrix4().translate(-((float)m_iSceneVolumeWidth) * m_fScaleSpacing, m_fScaleSpacing, 0);
            }
            mat = mat * Matrix4().translate(0, -((float)m_iSceneVolumeHeight) * m_fScaleSpacing, m_fScaleSpacing);
        }
        m_uiVertcount[i] = vertdataarrays[i].size() / 5;

        glGenVertexArrays(1, &m_unSceneVAO[i]);
        glBindVertexArray(m_unSceneVAO[i]);

        glGenBuffers(1, &m_glSceneVertBuffer[i]);
        glBindBuffer(GL_ARRAY_BUFFER, m_glSceneVertBuffer[i]);
        glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertdataarrays[i].size(), &vertdataarrays[i][0], GL_STATIC_DRAW);

        GLsizei stride = sizeof(VertexDataScene);
        uintptr_t offset = 0;

        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (const void*)offset);

        offset += sizeof(Vector3);
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, (const void*)offset);

        glBindVertexArray(0);
        glDisableVertexAttribArray(0);
        glDisableVertexAttribArray(1);
    }
}

Matrix4 HMD::GetHMDMatrixProjectionEye(vr::Hmd_Eye nEye)
{
    if (!VRSystem) {
        std::cout << "Failed to Get HMD Projection matrix" << std::endl;
        return Matrix4();
    }
    vr::HmdMatrix44_t mat = VRSystem->GetProjectionMatrix(nEye, m_fNearClip, m_fFarClip);

    return Matrix4(
        mat.m[0][0], mat.m[1][0], mat.m[2][0], mat.m[3][0],
        mat.m[0][1], mat.m[1][1], mat.m[2][1], mat.m[3][1],
        mat.m[0][2], mat.m[1][2], mat.m[2][2], mat.m[3][2],
        mat.m[0][3], mat.m[1][3], mat.m[2][3], mat.m[3][3]
    );
}

Matrix4 HMD::GetHMDMatrixPoseEye(vr::Hmd_Eye nEye)
{
    if (!VRSystem)
    {
        std::cout << "Failed to Get Pose matrix" << std::endl;
        return Matrix4();
    }
    vr::HmdMatrix34_t matEyeRight = VRSystem->GetEyeToHeadTransform(nEye);
    Matrix4 matrixObj(
        matEyeRight.m[0][0], matEyeRight.m[1][0], matEyeRight.m[2][0], 0.0,
        matEyeRight.m[0][1], matEyeRight.m[1][1], matEyeRight.m[2][1], 0.0,
        matEyeRight.m[0][2], matEyeRight.m[1][2], matEyeRight.m[2][2], 0.0,
        matEyeRight.m[0][3], matEyeRight.m[1][3], matEyeRight.m[2][3], 1.0f
    );

    return matrixObj.invert();
}


void HMD::SetupCameras()
{
    m_mat4ProjectionLeft = GetHMDMatrixProjectionEye(vr::Eye_Left);
    m_mat4ProjectionRight = GetHMDMatrixProjectionEye(vr::Eye_Right);
    m_mat4eyePosLeft = GetHMDMatrixPoseEye(vr::Eye_Left);
    m_mat4eyePosRight = GetHMDMatrixPoseEye(vr::Eye_Right);
}


/* Create Frame buffer  */
bool HMD::CreateFrameBuffer(int nWidth, int nHeight, FramebufferDesc& framebufferDesc)
{
    glGenFramebuffers(1, &framebufferDesc.m_nRenderFramebufferId);
    glBindFramebuffer(GL_FRAMEBUFFER, framebufferDesc.m_nRenderFramebufferId);

    glGenRenderbuffers(1, &framebufferDesc.m_nDepthBufferId);
    glBindRenderbuffer(GL_RENDERBUFFER, framebufferDesc.m_nDepthBufferId);
    glRenderbufferStorageMultisample(GL_RENDERBUFFER, 4, GL_DEPTH_COMPONENT, nWidth, nHeight);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, framebufferDesc.m_nDepthBufferId);

    glGenTextures(1, &framebufferDesc.m_nRenderTextureId);
    glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, framebufferDesc.m_nRenderTextureId);
    glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, 4, GL_RGBA8, nWidth, nHeight, true);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D_MULTISAMPLE, framebufferDesc.m_nRenderTextureId, 0);

    glGenFramebuffers(1, &framebufferDesc.m_nResolveFramebufferId);
    glBindFramebuffer(GL_FRAMEBUFFER, framebufferDesc.m_nResolveFramebufferId);

    glGenTextures(1, &framebufferDesc.m_nResolveTextureId);
    glBindTexture(GL_TEXTURE_2D, framebufferDesc.m_nResolveTextureId);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, nWidth, nHeight, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, framebufferDesc.m_nResolveTextureId, 0);

    // check FBO status
    GLenum status = glCheckFramebufferStatus(GL_FRAMEBUFFER);
    if (status != GL_FRAMEBUFFER_COMPLETE)
    {
        return false;
    }

    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    return true;
}

bool HMD::SetupStereoRenderTargets()
{
    if (!VRSystem) {
        std::cout << "Setup Stereo Render Target process failed.. program exit" << std::endl;
        return false;
    }
    VRSystem->GetRecommendedRenderTargetSize(&m_nRenderWidth, &m_nRenderHeight);

    CreateFrameBuffer(m_nRenderWidth, m_nRenderHeight, leftEyeDesc);
    CreateFrameBuffer(m_nRenderWidth, m_nRenderHeight, rightEyeDesc);

    return true;
}

void HMD::SetupCompanionWindow()
{
    if (!VRSystem)
        return;

    std::vector<VertexDataWindow> vVerts;

    // left eye verts
    vVerts.push_back(VertexDataWindow(Vector2(-1, -1), Vector2(0, 1)));
    vVerts.push_back(VertexDataWindow(Vector2(0, -1), Vector2(1, 1)));
    vVerts.push_back(VertexDataWindow(Vector2(-1, 1), Vector2(0, 0)));
    vVerts.push_back(VertexDataWindow(Vector2(0, 1), Vector2(1, 0)));

    // right eye verts
    vVerts.push_back(VertexDataWindow(Vector2(0, -1), Vector2(0, 1)));
    vVerts.push_back(VertexDataWindow(Vector2(1, -1), Vector2(1, 1)));
    vVerts.push_back(VertexDataWindow(Vector2(0, 1), Vector2(0, 0)));
    vVerts.push_back(VertexDataWindow(Vector2(1, 1), Vector2(1, 0)));

    GLushort vIndices[] = { 0, 1, 3,   0, 3, 2,   4, 5, 7,   4, 7, 6 };
    m_uiCompanionWindowIndexSize = _countof(vIndices);

    glGenVertexArrays(1, &m_unCompanionWindowVAO);
    glBindVertexArray(m_unCompanionWindowVAO);

    glGenBuffers(1, &m_glCompanionWindowIDVertBuffer);
    glBindBuffer(GL_ARRAY_BUFFER, m_glCompanionWindowIDVertBuffer);
    glBufferData(GL_ARRAY_BUFFER, vVerts.size() * sizeof(VertexDataWindow), &vVerts[0], GL_STATIC_DRAW);

    glGenBuffers(1, &m_glCompanionWindowIDIndexBuffer);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_glCompanionWindowIDIndexBuffer);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, m_uiCompanionWindowIndexSize * sizeof(GLushort), &vIndices[0], GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(VertexDataWindow), (void*)offsetof(VertexDataWindow, position));

    glEnableVertexAttribArray(1);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(VertexDataWindow), (void*)offsetof(VertexDataWindow, texCoord));

    glBindVertexArray(0);

    glDisableVertexAttribArray(0);
    glDisableVertexAttribArray(1);

    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
}

/* Returns true if the action is active and had a rising edge*/
bool GetDigitalActionRisingEdge(vr::VRActionHandle_t action, vr::VRInputValueHandle_t* pDevicePath = nullptr)
{
    vr::InputDigitalActionData_t actionData;
    vr::VRInput()->GetDigitalActionData(action, &actionData, sizeof(actionData), vr::k_ulInvalidInputValueHandle);
    if (pDevicePath)
    {
        *pDevicePath = vr::k_ulInvalidInputValueHandle;
        if (actionData.bActive)
        {
            vr::InputOriginInfo_t originInfo;
            if (vr::VRInputError_None == vr::VRInput()->GetOriginTrackedDeviceInfo(actionData.activeOrigin, &originInfo, sizeof(originInfo)))
            {
                *pDevicePath = originInfo.devicePath;
            }
        }
    }
    return actionData.bActive && actionData.bChanged && actionData.bState;
}

/* Returns true if the action is active and its state is true */
bool GetDigitalActionState(vr::VRActionHandle_t action, vr::VRInputValueHandle_t* pDevicePath = nullptr)
{
    vr::InputDigitalActionData_t actionData;
    vr::VRInput()->GetDigitalActionData(action, &actionData, sizeof(actionData), vr::k_ulInvalidInputValueHandle);
    if (pDevicePath)
    {
        *pDevicePath = vr::k_ulInvalidInputValueHandle;
        if (actionData.bActive)
        {
            vr::InputOriginInfo_t originInfo;
            if (vr::VRInputError_None == vr::VRInput()->GetOriginTrackedDeviceInfo(actionData.activeOrigin, &originInfo, sizeof(originInfo)))
            {
                *pDevicePath = originInfo.devicePath;
            }
        }
    }
    return actionData.bActive && actionData.bState;
}


void HMD::ProcessVREvent(const vr::VREvent_t& event)
{
    switch (event.eventType)
    {
    case vr::VREvent_TrackedDeviceDeactivated:
    {
        std::cout << "Device detached" << std::endl;;
    }
    break;
    case vr::VREvent_TrackedDeviceUpdated:
    {
        std::cout << "Device updated" << std::endl;;
    }
    break;
    }
}

RenderModel* HMD::FindOrLoadRenderModel(const char* pchRenderModelName)
{
    RenderModel* pRenderModel = NULL;
    for (std::vector< RenderModel* >::iterator i = m_vecRenderModels.begin(); i != m_vecRenderModels.end(); i++)
    {
        if (!stricmp((*i)->GetName().c_str(), pchRenderModelName))
        {
            pRenderModel = *i;
            break;
        }
    }

    // load the model if we didn't find one
    if (!pRenderModel)
    {
        vr::RenderModel_t* pModel;
        vr::EVRRenderModelError error;
        while (1)
        {
            error = vr::VRRenderModels()->LoadRenderModel_Async(pchRenderModelName, &pModel);
            if (error != vr::VRRenderModelError_Loading)
                break;

            ThreadSleep(1);
        }

        if (error != vr::VRRenderModelError_None)
        {
            std::cout << "Unable to load render model" <<  pchRenderModelName << vr::VRRenderModels()->GetRenderModelErrorNameFromEnum(error) << std::endl;
            return NULL; // move on to the next tracked device
        }

        vr::RenderModel_TextureMap_t* pTexture;
        while (1)
        {
            error = vr::VRRenderModels()->LoadTexture_Async(pModel->diffuseTextureId, &pTexture);
            if (error != vr::VRRenderModelError_Loading)
                break;

            ThreadSleep(1);
        }

        if (error != vr::VRRenderModelError_None)
        {
            std::cout<<"Unable to load render texture id:  " << pModel->diffuseTextureId << "for render model: " << pchRenderModelName << std::endl;
            vr::VRRenderModels()->FreeRenderModel(pModel);
            return NULL; // move on to the next tracked device
        }

        pRenderModel = new RenderModel(pchRenderModelName);
        if (!pRenderModel->BInit(*pModel, *pTexture))
        {
            std::cout<<"Unable to create GL model from render model: " <<  pchRenderModelName << std::endl;
            delete pRenderModel;
            pRenderModel = NULL;
        }
        else
        {
            m_vecRenderModels.push_back(pRenderModel);
        }
        vr::VRRenderModels()->FreeRenderModel(pModel);
        vr::VRRenderModels()->FreeTexture(pTexture);
    }
    return pRenderModel;
}

Matrix4 HMD::ConvertSteamVRMatrixToMatrix4(const vr::HmdMatrix34_t& matPose)
{
    Matrix4 matrixObj(
        matPose.m[0][0], matPose.m[1][0], matPose.m[2][0], 0.0,
        matPose.m[0][1], matPose.m[1][1], matPose.m[2][1], 0.0,
        matPose.m[0][2], matPose.m[1][2], matPose.m[2][2], 0.0,
        matPose.m[0][3], matPose.m[1][3], matPose.m[2][3], 1.0f
    );
    return matrixObj;
}

/* Event Handler */
bool HMD::HandleInput()
{
    SDL_Event sdlEvent;
    bool bRet = false;

    while (SDL_PollEvent(&sdlEvent) != 0)
    {
        if (sdlEvent.type == SDL_QUIT)
        {
            bRet = true;
        }
        else if (sdlEvent.type == SDL_KEYDOWN)
        {
            if (sdlEvent.key.keysym.sym == SDLK_ESCAPE
                || sdlEvent.key.keysym.sym == SDLK_q)
            {
                bRet = true;
            }
            if (sdlEvent.key.keysym.sym == SDLK_c)
            {
                m_bShowCubes = !m_bShowCubes;
            }
        }
    }

    // Process SteamVR events
    vr::VREvent_t event;
    while (VRSystem->PollNextEvent(&event, sizeof(event)))
    {
        ProcessVREvent(event);
    }

    // Process SteamVR action state
    // UpdateActionState is called each frame to update the state of the actions themselves. The application
    // controls which action sets are active with the provided array of VRActiveActionSet_t structs.
    vr::VRActiveActionSet_t actionSet = { 0 };
    actionSet.ulActionSet = m_actionsetDemo;
    vr::VRInput()->UpdateActionState(&actionSet, sizeof(actionSet), 1);

    m_bShowCubes = !GetDigitalActionState(m_actionHideCubes);

    vr::VRInputValueHandle_t ulHapticDevice;
    if (GetDigitalActionRisingEdge(m_actionTriggerHaptic, &ulHapticDevice))
    {
        if (ulHapticDevice == m_rHand[Left].m_source)
        {
            vr::VRInput()->TriggerHapticVibrationAction(m_rHand[Left].m_actionHaptic, 0, 1, 4.f, 1.0f, vr::k_ulInvalidInputValueHandle);
        }
        if (ulHapticDevice == m_rHand[Right].m_source)
        {
            vr::VRInput()->TriggerHapticVibrationAction(m_rHand[Right].m_actionHaptic, 0, 1, 4.f, 1.0f, vr::k_ulInvalidInputValueHandle);
        }
    }

    vr::InputAnalogActionData_t analogData;
    if (vr::VRInput()->GetAnalogActionData(m_actionAnalongInput, &analogData, sizeof(analogData), vr::k_ulInvalidInputValueHandle) == vr::VRInputError_None && analogData.bActive)
    {
        m_vAnalogValue[0] = analogData.x;
        m_vAnalogValue[1] = analogData.y;
    }

    m_rHand[Left].m_bShowController = true;
    m_rHand[Right].m_bShowController = true;

    vr::VRInputValueHandle_t ulHideDevice;
    if (GetDigitalActionState(m_actionHideThisController, &ulHideDevice))
    {
        if (ulHideDevice == m_rHand[Left].m_source)
        {
            m_rHand[Left].m_bShowController = false;
        }
        if (ulHideDevice == m_rHand[Right].m_source)
        {
            m_rHand[Right].m_bShowController = false;
        }
    }

    for (EHand eHand = Left; eHand <= Right; ((int&)eHand)++)
    {
        vr::InputPoseActionData_t poseData;
        if (vr::VRInput()->GetPoseActionDataForNextFrame(m_rHand[eHand].m_actionPose, vr::TrackingUniverseStanding, &poseData, sizeof(poseData), vr::k_ulInvalidInputValueHandle) != vr::VRInputError_None
            || !poseData.bActive || !poseData.pose.bPoseIsValid)
        {
            m_rHand[eHand].m_bShowController = false;
        }
        else
        {
            m_rHand[eHand].m_rmat4Pose = ConvertSteamVRMatrixToMatrix4(poseData.pose.mDeviceToAbsoluteTracking);

            vr::InputOriginInfo_t originInfo;
            if (vr::VRInput()->GetOriginTrackedDeviceInfo(poseData.activeOrigin, &originInfo, sizeof(originInfo)) == vr::VRInputError_None
                && originInfo.trackedDeviceIndex != vr::k_unTrackedDeviceIndexInvalid)
            {
                std::string sRenderModelName = GetTrackedDeviceString(originInfo.trackedDeviceIndex, vr::Prop_RenderModelName_String);
                if (sRenderModelName != m_rHand[eHand].m_sRenderModelName)
                {
                    m_rHand[eHand].m_pRenderModel = FindOrLoadRenderModel(sRenderModelName.c_str());
                    m_rHand[eHand].m_sRenderModelName = sRenderModelName;
                }
            }
        }
    }

    return bRet;
}



/* HMD Initialization IMPLEMENTATION*/


void HMD::init() {
    ros::init(this->argc_arg, this->argv_arg, "HMD");
    ros::NodeHandle node;
    hmd_pub = node.advertise<VR::matrix_3_4>("HMD", 1000);
    leftCon_pub = node.advertise<VR::matrix_3_4>("LEFTCONTROLLER", 1000);
    rightCon_pub = node.advertise<VR::matrix_3_4>("RIGHTCONTROLLER", 1000);

    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_TIMER) < 0)
    {
        printf("%s - SDL could not initialize! SDL Error: %s\n", __FUNCTION__, SDL_GetError());
        return;
    }


    eError = vr::VRInitError_None;
    VRSystem = vr::VR_Init(&eError, vr::VRApplication_Scene);

    if (eError != vr::VRInitError_None)
    {
        char buf[1024];
        sprintf_s(buf, sizeof(buf), "Unable to init VR runtime: %s", vr::VR_GetVRInitErrorAsEnglishDescription(eError));
        SDL_ShowSimpleMessageBox(SDL_MESSAGEBOX_ERROR, "VR_Init Failed", buf, NULL);
        return;
    }

    /* SDL based Window Creation Process Start */

    int nWindowPosX = 700;
    int nWindowPosY = 100;
    Uint32 unWindowFlags = SDL_WINDOW_OPENGL | SDL_WINDOW_SHOWN;

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);
    //SDL_GL_SetAttribute( SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_COMPATIBILITY );
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);

    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 0);
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 0);

    if (m_bDebugOpenGL)
        SDL_GL_SetAttribute(SDL_GL_CONTEXT_FLAGS, SDL_GL_CONTEXT_DEBUG_FLAG);

    m_pCompanionWindow = SDL_CreateWindow("hellovr", nWindowPosX, nWindowPosY, m_nCompanionWindowWidth, m_nCompanionWindowHeight, unWindowFlags);

    if (m_pCompanionWindow == NULL)
    {
        printf("%s - Window could not be created! SDL Error: %s\n", __FUNCTION__, SDL_GetError());
        return;
    }

    m_pContext = SDL_GL_CreateContext(m_pCompanionWindow);
    if (m_pContext == NULL)
    {
        printf("%s - OpenGL context could not be created! SDL Error: %s\n", __FUNCTION__, SDL_GetError());
        return;
    }
    

    glewExperimental = GL_TRUE;
    GLenum nGlewError = glewInit();


    if (nGlewError != GLEW_OK)
    {
        printf("%s - Error initializing GLEW! %s\n", __FUNCTION__, glewGetErrorString(nGlewError));
        return;
    }
    glGetError(); // to clear the error caused deep in GLEW

    if (SDL_GL_SetSwapInterval(m_bVblank ? 1 : 0) < 0)
    {
        printf("%s - Warning: Unable to set VSync! SDL Error: %s\n", __FUNCTION__, SDL_GetError());
        return;
    }

    m_strDriver = "No Driver";
    m_strDisplay = "No Display";

    m_strDriver = GetTrackedDeviceString(vr::k_unTrackedDeviceIndex_Hmd, vr::Prop_TrackingSystemName_String);
    m_strDisplay = GetTrackedDeviceString(vr::k_unTrackedDeviceIndex_Hmd, vr::Prop_SerialNumber_String);

    std::string strWindowTitle = "hellovr - " + m_strDriver + " " + m_strDisplay;
    SDL_SetWindowTitle(m_pCompanionWindow, strWindowTitle.c_str());

    // cube array
    m_iSceneVolumeWidth = m_iSceneVolumeInit;
    m_iSceneVolumeHeight = m_iSceneVolumeInit;
    m_iSceneVolumeDepth = m_iSceneVolumeInit;

    m_fScale = 10.0f;
    m_fScaleSpacing = 0.0f;

    m_fNearClip = 0.1f;
    m_fFarClip = 30.0f;


    /* Window Creation Process End */

    /* OpenGL Initialization Start*/

    if (!CreateAllShaders())
        return;

    SetupTexturemaps();
    SetupScene();
    SetupCameras();
    SetupStereoRenderTargets();
    SetupCompanionWindow();

    /* OpenGL Initialization End*/

    if (!vr::VRCompositor()) {
        std::cout << "Compositor initialization failed" << std::endl;
        return;
    }

    std::cout << "VR Compositor Initialization Success!" << std::endl;
    
    std::cout << "Start Connection Check" << std::endl;
    checkConnection();

    ricoh_sub = node.subscribe<std_msgs::UInt8MultiArray>("/ricoh_h264_stream", 2, boost::bind(streamCallback, _1, &streamObj, this));


    vr::VRInput()->SetActionManifestPath(Path_MakeAbsolute("C:/Users/Dyros/Desktop/avatar/src/VR/src/hellovr_actions.json", Path_StripFilename(Path_GetExecutablePath())).c_str());

    vr::VRInput()->GetActionHandle("/actions/demo/in/HideCubes", &m_actionHideCubes);
    vr::VRInput()->GetActionHandle("/actions/demo/in/HideThisController", &m_actionHideThisController);
    vr::VRInput()->GetActionHandle("/actions/demo/in/TriggerHaptic", &m_actionTriggerHaptic);
    vr::VRInput()->GetActionHandle("/actions/demo/in/AnalogInput", &m_actionAnalongInput);

    vr::VRInput()->GetActionSetHandle("/actions/demo", &m_actionsetDemo);

    vr::VRInput()->GetActionHandle("/actions/demo/out/Haptic_Left", &m_rHand[Left].m_actionHaptic);
    vr::VRInput()->GetInputSourceHandle("/user/hand/left", &m_rHand[Left].m_source);
    vr::VRInput()->GetActionHandle("/actions/demo/in/Hand_Left", &m_rHand[Left].m_actionPose);

    vr::VRInput()->GetActionHandle("/actions/demo/out/Haptic_Right", &m_rHand[Right].m_actionHaptic);
    vr::VRInput()->GetInputSourceHandle("/user/hand/right", &m_rHand[Right].m_source);
    vr::VRInput()->GetActionHandle("/actions/demo/in/Hand_Right", &m_rHand[Right].m_actionPose);


}



void HMD::RunMainLoop()
{
    bool bQuit = false;

    SDL_StartTextInput();
    SDL_ShowCursor(SDL_DISABLE);

    while (ros::ok())
    {
        bQuit = HandleInput();
        RenderFrame();

        ros::spinOnce();
    }

    SDL_StopTextInput();
}

void HMD::RenderFrame()
{
    // for now as fast as possible
    if (VRSystem)
    {
        RenderControllerAxes();
        RenderStereoTargets();
        RenderCompanionWindow();

        vr::Texture_t leftEyeTexture = { (void*)(uintptr_t)leftEyeDesc.m_nResolveTextureId, vr::TextureType_OpenGL, vr::ColorSpace_Gamma };
        vr::VRCompositor()->Submit(vr::Eye_Left, &leftEyeTexture);
        vr::Texture_t rightEyeTexture = { (void*)(uintptr_t)rightEyeDesc.m_nResolveTextureId, vr::TextureType_OpenGL, vr::ColorSpace_Gamma };
        vr::VRCompositor()->Submit(vr::Eye_Right, &rightEyeTexture);
    }

    if (m_bVblank && m_bGlFinishHack)
    {
        //$ HACKHACK. From gpuview profiling, it looks like there is a bug where two renders and a present
        // happen right before and after the vsync causing all kinds of jittering issues. This glFinish()
        // appears to clear that up. Temporary fix while I try to get nvidia to investigate this problem.
        // 1/29/2014 mikesart
        glFinish();
    }

    // SwapWindow
    {
        SDL_GL_SwapWindow(m_pCompanionWindow);
    }

    // Clear
    {
        // We want to make sure the glFinish waits for the entire present to complete, not just the submission
        // of the command. So, we do a clear here right here so the glFinish will wait fully for the swap.
        glClearColor(0, 0, 0, 1);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    // Flush and wait for swap.
    if (m_bVblank)
    {
        glFlush();
        glFinish();
    }

    // Spew out the controller and pose count whenever they change.
    if (m_iTrackedControllerCount != m_iTrackedControllerCount_Last || m_iValidPoseCount != m_iValidPoseCount_Last)
    {
        m_iValidPoseCount_Last = m_iValidPoseCount;
        m_iTrackedControllerCount_Last = m_iTrackedControllerCount;

        printf("PoseCount:%d(%s) Controllers:%d\n", m_iValidPoseCount, m_strPoseClasses.c_str(), m_iTrackedControllerCount);
    }

    UpdateHMDMatrixPose();
}

void HMD::UpdateHMDMatrixPose()
{
    if (!VRSystem)
        return;

    vr::VRCompositor()->WaitGetPoses(m_rTrackedDevicePose, vr::k_unMaxTrackedDeviceCount, NULL, 0);

    m_iValidPoseCount = 0;
    m_strPoseClasses = "";
    for (int nDevice = 0; nDevice < vr::k_unMaxTrackedDeviceCount; ++nDevice)
    {
        if (m_rTrackedDevicePose[nDevice].bPoseIsValid)
        {
            m_iValidPoseCount++;
            //if(VRSystem->GetTrackedDeviceClass(nDevice) == vr::TrackedDeviceClass_HMD)
              //  std::cout << m_rTrackedDevicePose[nDevice].mDeviceToAbsoluteTracking.m[2][3] << std::endl;

            m_rmat4DevicePose[nDevice] = ConvertSteamVRMatrixToMatrix4(m_rTrackedDevicePose[nDevice].mDeviceToAbsoluteTracking);
            if (m_rDevClassChar[nDevice] == 0)
            {
                switch (VRSystem->GetTrackedDeviceClass(nDevice))
                {
                case vr::TrackedDeviceClass_Controller:        m_rDevClassChar[nDevice] = 'C'; break;
                case vr::TrackedDeviceClass_HMD:               m_rDevClassChar[nDevice] = 'H'; break;
                case vr::TrackedDeviceClass_Invalid:           m_rDevClassChar[nDevice] = 'I'; break;
                case vr::TrackedDeviceClass_GenericTracker:    m_rDevClassChar[nDevice] = 'G'; break;
                case vr::TrackedDeviceClass_TrackingReference: m_rDevClassChar[nDevice] = 'T'; break;
                default:                                       m_rDevClassChar[nDevice] = '?'; break;
                }
            }
            m_strPoseClasses += m_rDevClassChar[nDevice];
        }
    }

    if (m_rTrackedDevicePose[vr::k_unTrackedDeviceIndex_Hmd].bPoseIsValid)
    {
        m_mat4HMDPose = m_rmat4DevicePose[vr::k_unTrackedDeviceIndex_Hmd];
        //std::cout << m_mat4HMDPose << std::endl;

        m_mat4HMDPose.invert();
    }
}



// Purpose: Draw all of the controllers as X/Y/Z lines
//-----------------------------------------------------------------------------
void HMD::RenderControllerAxes()
{
    // Don't attempt to update controllers if input is not available
    if (!VRSystem->IsInputAvailable())
        return;

    std::vector<float> vertdataarray;

    m_uiControllerVertcount = 0;
    m_iTrackedControllerCount = 0;

    for (EHand eHand = Left; eHand <= Right; ((int&)eHand)++)
    {
        if (!m_rHand[eHand].m_bShowController)
            continue;

        const Matrix4& mat = m_rHand[eHand].m_rmat4Pose;

        Vector4 center = mat * Vector4(0, 0, 0, 1);

        for (int i = 0; i < 3; ++i)
        {
            Vector3 color(0, 0, 0);
            Vector4 point(0, 0, 0, 1);
            point[i] += 0.05f;  // offset in X, Y, Z
            color[i] = 1.0;  // R, G, B
            point = mat * point;
            vertdataarray.push_back(center.x);
            vertdataarray.push_back(center.y);
            vertdataarray.push_back(center.z);

            vertdataarray.push_back(color.x);
            vertdataarray.push_back(color.y);
            vertdataarray.push_back(color.z);

            vertdataarray.push_back(point.x);
            vertdataarray.push_back(point.y);
            vertdataarray.push_back(point.z);

            vertdataarray.push_back(color.x);
            vertdataarray.push_back(color.y);
            vertdataarray.push_back(color.z);

            m_uiControllerVertcount += 2;
        }

        Vector4 start = mat * Vector4(0, 0, -0.02f, 1);
        Vector4 end = mat * Vector4(0, 0, -39.f, 1);
        Vector3 color(.92f, .92f, .71f);

        vertdataarray.push_back(start.x); vertdataarray.push_back(start.y); vertdataarray.push_back(start.z);
        vertdataarray.push_back(color.x); vertdataarray.push_back(color.y); vertdataarray.push_back(color.z);

        vertdataarray.push_back(end.x); vertdataarray.push_back(end.y); vertdataarray.push_back(end.z);
        vertdataarray.push_back(color.x); vertdataarray.push_back(color.y); vertdataarray.push_back(color.z);
        m_uiControllerVertcount += 2;
    }

    // Setup the VAO the first time through.
    if (m_unControllerVAO == 0)
    {
        glGenVertexArrays(1, &m_unControllerVAO);
        glBindVertexArray(m_unControllerVAO);

        glGenBuffers(1, &m_glControllerVertBuffer);
        glBindBuffer(GL_ARRAY_BUFFER, m_glControllerVertBuffer);

        GLuint stride = 2 * 3 * sizeof(float);
        uintptr_t offset = 0;

        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (const void*)offset);

        offset += sizeof(Vector3);
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (const void*)offset);

        glBindVertexArray(0);
    }

    glBindBuffer(GL_ARRAY_BUFFER, m_glControllerVertBuffer);

    // set vertex data if we have some
    if (vertdataarray.size() > 0)
    {
        //$ TODO: Use glBufferSubData for this...
        glBufferData(GL_ARRAY_BUFFER, sizeof(float) * vertdataarray.size(), &vertdataarray[0], GL_STREAM_DRAW);
    }
}

Matrix4 HMD::GetCurrentViewProjectionMatrix(vr::Hmd_Eye nEye)
{
    Matrix4 matMVP;
    Matrix4 matTransform;
    
    //matTransform.translate(-3.5, 0.0, 0.0);
    //std::cout << m_mat4eyePosLeft << std::endl;
    //std::cout << m_mat4HMDPose << std::endl << std::endl;
    
    if (nEye == vr::Eye_Left)
    {   
        
        matMVP = m_mat4ProjectionLeft * m_mat4eyePosLeft  * m_mat4HMDPose;
    }
    else if (nEye == vr::Eye_Right)
    {
        matMVP = m_mat4ProjectionRight * m_mat4eyePosRight  * m_mat4HMDPose;
    }

    return matMVP;
}



/* Render scene respect to each eye */
void HMD::RenderScene(vr::Hmd_Eye nEye)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);

    if (m_bShowCubes)
    {
        glUseProgram(m_unSceneProgramID);
        glUniformMatrix4fv(m_nSceneMatrixLocation, 1, GL_FALSE, GetCurrentViewProjectionMatrix(nEye).get());
        for (int i = 0; i < 6; i++) {
            glBindVertexArray(m_unSceneVAO[i]);
            glBindTexture(GL_TEXTURE_2D, m_Texture[i]);
            glDrawArrays(GL_TRIANGLES, 0, m_uiVertcount[i]);
            glBindVertexArray(0);
        }
    }

    bool bIsInputAvailable = VRSystem->IsInputAvailable();

    if (bIsInputAvailable)
    {
        // draw the controller axis lines
        glUseProgram(m_unControllerTransformProgramID);
        glUniformMatrix4fv(m_nControllerMatrixLocation, 1, GL_FALSE, GetCurrentViewProjectionMatrix(nEye).get());
        glBindVertexArray(m_unControllerVAO);
        glDrawArrays(GL_LINES, 0, m_uiControllerVertcount);
        glBindVertexArray(0);
    }

    // ----- Render Model rendering -----
    glUseProgram(m_unRenderModelProgramID);

    for (EHand eHand = Left; eHand <= Right; ((int&)eHand)++)
    {
        if (!m_rHand[eHand].m_bShowController || !m_rHand[eHand].m_pRenderModel)
            continue;

        const Matrix4& matDeviceToTracking = m_rHand[eHand].m_rmat4Pose;
        Matrix4 matMVP = GetCurrentViewProjectionMatrix(nEye) * matDeviceToTracking;
        glUniformMatrix4fv(m_nRenderModelMatrixLocation, 1, GL_FALSE, matMVP.get());

        m_rHand[eHand].m_pRenderModel->Draw();
    }

    glUseProgram(0);
}

void HMD::RenderStereoTargets()
{
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glEnable(GL_MULTISAMPLE);

    // Left Eye
    glBindFramebuffer(GL_FRAMEBUFFER, leftEyeDesc.m_nRenderFramebufferId);
    glViewport(0, 0, m_nRenderWidth, m_nRenderHeight);
    RenderScene(vr::Eye_Left);
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    glDisable(GL_MULTISAMPLE);

    glBindFramebuffer(GL_READ_FRAMEBUFFER, leftEyeDesc.m_nRenderFramebufferId);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, leftEyeDesc.m_nResolveFramebufferId);

    glBlitFramebuffer(0, 0, m_nRenderWidth, m_nRenderHeight, 0, 0, m_nRenderWidth, m_nRenderHeight,
        GL_COLOR_BUFFER_BIT,
        GL_LINEAR);

    glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);

    glEnable(GL_MULTISAMPLE);

    // Right Eye
    glBindFramebuffer(GL_FRAMEBUFFER, rightEyeDesc.m_nRenderFramebufferId);
    glViewport(0, 0, m_nRenderWidth, m_nRenderHeight);
    RenderScene(vr::Eye_Right);
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    glDisable(GL_MULTISAMPLE);

    glBindFramebuffer(GL_READ_FRAMEBUFFER, rightEyeDesc.m_nRenderFramebufferId);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, rightEyeDesc.m_nResolveFramebufferId);

    glBlitFramebuffer(0, 0, m_nRenderWidth, m_nRenderHeight, 0, 0, m_nRenderWidth, m_nRenderHeight,
        GL_COLOR_BUFFER_BIT,
        GL_LINEAR);

    glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
    glBindFramebuffer(GL_DRAW_FRAMEBUFFER, 0);
}

void HMD::RenderCompanionWindow()
{
    glDisable(GL_DEPTH_TEST);
    glViewport(0, 0, m_nCompanionWindowWidth, m_nCompanionWindowHeight);

    glBindVertexArray(m_unCompanionWindowVAO);
    glUseProgram(m_unCompanionWindowProgramID);

    // render left eye (first half of index array )
    glBindTexture(GL_TEXTURE_2D, leftEyeDesc.m_nResolveTextureId);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glDrawElements(GL_TRIANGLES, m_uiCompanionWindowIndexSize / 2, GL_UNSIGNED_SHORT, 0);

    // render right eye (second half of index array )
    glBindTexture(GL_TEXTURE_2D, rightEyeDesc.m_nResolveTextureId);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glDrawElements(GL_TRIANGLES, m_uiCompanionWindowIndexSize / 2, GL_UNSIGNED_SHORT, (const void*)(uintptr_t)(m_uiCompanionWindowIndexSize));

    glBindVertexArray(0);
    glUseProgram(0);
}





std::string HMD::faceNameToString(CubeFaceName faceName) {
    switch (faceName)
    {
    case CubeFaceName::Front:  return "Front";
    case CubeFaceName::Right:  return "Right";
    case CubeFaceName::Back:   return "Back";
    case CubeFaceName::Left:   return "Left";
    case CubeFaceName::Top:    return "Top";
    case CubeFaceName::Bottom: return "Bottom";
    default:           return "UNKNOWN";
    }
}

int HMD::faceNameToInteger(CubeFaceName faceName) {
    switch (faceName)
    {
    case CubeFaceName::Front:  return 0;
    case CubeFaceName::Right:  return 1;
    case CubeFaceName::Back:   return 2;
    case CubeFaceName::Left:   return 3;
    case CubeFaceName::Top:    return 4;
    case CubeFaceName::Bottom: return 5;
    }
}

bool HMD::createCubeMapFace(const cv::Mat& in, cv::Mat& face, CubeFaceName faceName, int stereo) {
    // we have to enforce input image dimensions to be equirectangular
    if (in.size().height != in.size().width / 2)
    {
        return false;
    }
    MapCoord* MAP_COORDS;
    if(stereo == 0)   MAP_COORDS = &LEFT_MAP_COORDS[0];
    else MAP_COORDS = &RIGHT_MAP_COORDS[0];

    const int faceId = (int)faceName;

    const float inWidth = in.cols;
    const float inHeight = in.rows;


    // calculate adjacent (ak) and opposite (an) of the
    // triangle that is spanned from the sphere center 
    // to our cube face
    const float an = sin(M_PI / 4);
    const float ak = cos(M_PI / 4);

    const float ftu = facesTable[faceId].polarCoords[0];
    const float ftv = facesTable[faceId].polarCoords[1];
    int index = faceNameToInteger(faceName);

    // for each point in the target image, 
    // calculate the corresponding source coordinates
    if (!MAP_COORDS[index].isSet) {
        MAP_COORDS[index].mapx = new cv::Mat(targetDim, targetDim, CV_32F);
        MAP_COORDS[index].mapy = new cv::Mat(targetDim, targetDim, CV_32F);
        std::cout << "Create mapping arrays..." << std::endl;
        for (int y = 0; y < targetDim; y++)
        {
            for (int x = 0; x < targetDim; x++)
            {
                // map face pixel coordinates to [-1, 1] on plane
                float nx = (float)y / (float)targetDim - 0.5f;
                float ny = (float)x / (float)targetDim - 0.5f;

                nx *= 2;
                ny *= 2;

                // map [-1, 1] plane coords to [-an, an]
                // thats the coordinates in respect to a unit sphere 
                // that contains our box
                nx *= an;
                ny *= an;

                float u, v;

                // project from plane to sphere surface
                if (ftv == 0)
                {
                    // center faces
                    u = atan2(nx, ak);
                    v = atan2(ny * cos(u), ak);
                    u += ftu;
                }
                else if (ftv > 0)
                {
                    // bottom face 
                    float d = sqrt(nx * nx + ny * ny);
                    v = M_PI / 2 - atan2(d, ak);
                    u = atan2(ny, nx);
                }
                else
                {
                    // top face
                    float d = sqrt(nx * nx + ny * ny);
                    v = -M_PI / 2 + atan2(d, ak);
                    u = atan2(-ny, nx);
                }

                // map from angular coordinates to [-1, 1], respectively
                u = u / (M_PI);
                v = v / (M_PI / 2);

                // warp around, if our coordinates are out of bounds
                while (v < -1)
                {
                    v += 2;
                    u += 1;
                }

                while (v > 1)
                {
                    v -= 2;
                    u += 1;
                }

                while (u < -1)
                {
                    u += 2;
                }

                while (u > 1)
                {
                    u -= 2;
                }

                // map from [-1, 1] to in texture space
                u = u / 2.0f + 0.5f;
                v = v / 2.0f + 0.5f;

                u = u * (inWidth - 1);
                v = v * (inHeight - 1);

                // save the result for this pixel in map
                MAP_COORDS[index].mapx[0].at<float>(x, y) = u;
                MAP_COORDS[index].mapy[0].at<float>(x, y) = v;
            }
        }
        MAP_COORDS[index].isSet = true;
        std::cout << "Transformation calculation between equirectangular & cubemap done" << std::endl;
    }

    // recreate output image if it has wrong size or type
    if (face.cols != targetDim || face.rows != targetDim || face.type() != in.type())
    {
        face = cv::Mat(targetDim, targetDim, in.type());
    }

    // run actual resampling using OpenCV's remap
    cv::remap(in, face, MAP_COORDS[index].mapx[0], MAP_COORDS[index].mapy[0], CV_INTER_CUBIC, cv::BORDER_CONSTANT, cv::Scalar(0, 0, 0));

    return true;
}







/* Check HMD, Controllers connection state */
void HMD::checkConnection() {
    std::cout << "Maximum Number of Device that can be tracked: " << vr::k_unMaxTrackedDeviceCount << std::endl;

    std::cout << "Please Connect Your HMD and two controllers to start this program" << std::endl;

    while (true) {
        int HMD_count = 0;
        int controller_count = 0;

        for (int i = 0; i < vr::k_unMaxTrackedDeviceCount; i++){;
            vr::ETrackedDeviceClass trackedStatus = VRSystem->GetTrackedDeviceClass(i);
            switch (int(trackedStatus)) {
            case 0:  continue;
            case 1:
                this->HMD_INDEX = i;
                HMD_count += 1;
                continue;
            case 2: {
                std::cout << "controller:   " << i << std::endl;
                vr::ETrackedControllerRole controllerRole = VRSystem->GetControllerRoleForTrackedDeviceIndex(vr::TrackedDeviceIndex_t(i));
                if (controllerRole == 1) {
                    std::cout << "controller:   " << i << "  Role: Left controller identified " << controllerRole << std::endl;
                    this->LEFT_CONTROLLER_INDEX = i;
                }
                else if (controllerRole == 2) {
                    std::cout << "controller:   " << i << "  Role: Right controller identified " << controllerRole << std::endl;
                    this->RIGHT_CONTROLLER_INDEX = i;
                }
                controller_count += 1;
                continue;
            }
            case 3:  continue;
            case 4:  continue;
            case 5:  continue;
            }
        }

        if (checkControllers && (HMD_count == 1 && controller_count == 2)) {
            break;
        }
        if (!checkControllers && HMD_count == 1) {
            break;
        }
    }

    if (checkControllers) {
        std::cout << "One HMD and Two controllers are identified..." << std::endl;
        std::cout << "HMD INDEX:  " << HMD_INDEX << std::endl << "LEFT CONTROLLER:  " << LEFT_CONTROLLER_INDEX << std::endl << "RIGHT CONTROLLER:  " << RIGHT_CONTROLLER_INDEX << std::endl;
        std::cout << "Start VR system and ROS NODE" << std::endl;
    }
    else {
        std::cout << "HMD is identified..." << std::endl;
        std::cout << "HMD INDEX:  " << HMD_INDEX << std::endl;
        std::cout << "All Specified Connection Identified.. Start VR system.." << std::endl;
    }
}




/* Private members IMPLEMENTATIOn*/
_FLOAT HMD::map2array(Mat eigen) {
    // Return 4x4 Eigen matrix to 3x4 c++ matrix
    _FLOAT array = new float[3][4];

    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 4; col++) {
            array[row][col] = eigen(row, col);
        }
    }
    return array;
}

Mat HMD::map2eigen(float array[][4]) {
    // Return 3x4 c++ matrix to 4x4 Eigen matrix
    Mat eigen;
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 4; col++) {
            eigen(row, col) = array[row][col];
        }
    }
    eigen(3, 0) = 0;
    eigen(3, 1) = 0;
    eigen(3, 2) = 0;
    eigen(3, 3) = 1;

    return eigen;
}

Mat HMD::coordinate_z(Mat array){

    Mat y_r;
    Mat x_r;
    Mat z_r;

    y_r << 0, 0, -1, 0,
        0, 1, 0, 0,
        1, 0, 0, 0,
        0, 0, 0, 1;
    x_r << 1, 0, 0, 0,
        0, 0, -1, 0,
        0, 1, 0, 0,
        0, 0, 0, 1;

    z_r << -1, 0, 0, 0,
        0, -1, 0, 0,
        0, 0, 1, 0,
        0, 0, 0, 1;
    Mat x_r_array = x_r * y_r * array;

    x_r_array.col(0) = x_r_array.col(0) * -1;
    x_r_array.col(1) = x_r_array.col(1) * -1;

    return  x_r_array;
}

Mat HMD::coordinate(Mat array) {
    Mat y_r;
    Mat x_r;
    Mat z_r;

    y_r << 0, 0, -1, 0,
        0, 1, 0, 0,
        1, 0, 0, 0,
        0, 0, 0, 1;
    x_r << 1, 0, 0, 0,
        0, 0, -1, 0,
        0, 1, 0, 0,
        0, 0, 0, 1;

    return   x_r * y_r * array;
}

VR::matrix_3_4 HMD::makeTrackingmsg(_FLOAT array) {
    VR::matrix_3_4 msg;

    for (int i = 0; i < 4; i++) msg.firstRow.push_back(array[0][i]);
    for (int i = 0; i < 4; i++) msg.secondRow.push_back(array[1][i]);
    for (int i = 0; i < 4; i++) msg.thirdRow.push_back(array[2][i]);

    return msg;
}
void HMD::rosPublish() {
    while (ros::ok()) {

        VRSystem->GetDeviceToAbsoluteTrackingPose(vr::TrackingUniverseSeated, 0, m_rTrackedDevicePose, vr::k_unMaxTrackedDeviceCount);

        // HMD : Send only rotation parameters(euler or quarternion)
        // controller : Send rotation & translation parameters(w.r.t current HMD Cordinate)

         HMD_curEig = map2eigen(m_rTrackedDevicePose[HMD_INDEX].mDeviceToAbsoluteTracking.m);
         HMD_world = map2array(refMatInv * HMD_curEig);
         HMD_world_coord_change = map2array(coordinate(refMatInv * HMD_curEig));
         HMD_worldEigInv = map2eigen(HMD_world).inverse();
        if (checkControllers) {
             LEFTCONTROLLER_curEig = map2eigen(m_rTrackedDevicePose[LEFT_CONTROLLER_INDEX].mDeviceToAbsoluteTracking.m);
             RIGHTCONTROLLER_curEig = map2eigen(m_rTrackedDevicePose[RIGHT_CONTROLLER_INDEX].mDeviceToAbsoluteTracking.m);
             HMD_LEFTCONTROLLER = map2array(coordinate_z(HMD_curEig.inverse() * LEFTCONTROLLER_curEig));
             HMD_RIGHTCONTROLLER = map2array(coordinate_z(HMD_curEig.inverse() * RIGHTCONTROLLER_curEig));
        }
        if (pubPose) {
            hmd_pub.publish(makeTrackingmsg(HMD_world_coord_change));
            if (checkControllers) {
                leftCon_pub.publish(makeTrackingmsg(HMD_LEFTCONTROLLER));
                rightCon_pub.publish(makeTrackingmsg(HMD_RIGHTCONTROLLER));
            }
        }

        ros::spinOnce();
    }

}


